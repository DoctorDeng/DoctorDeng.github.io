---
layout: post
title: Java SSM 框架知识整理
categories: [java, SSM]
description: 介绍 Spring+SpringMVC+Mybatis集合框架的一些知识
keywords: java, SSM
---

介绍 Spring+SpringMVC+Mybatis集合框架的一些知识

## 1、什么是 ORM？
对象关系映射（Object-Relational Mapping，简称ORM）,是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术；简单的说，ORM 是通过使用描述对象和数据库之间映射的元数据（在Java中可以用XML或者是注解），将程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成Java对象，其本质上就是将数据从一种形式转换到另外一种形式。

## 2、持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？ 
所谓"持久"就是将数据保存到可掉电式存储设备中以便今后使用，简单的说，就是将内存中的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中。持久层就是系统中专注于实现数据持久化的相对独立的层面。

持久层设计的目标包括：

    * 数据存储逻辑的分离，提供抽象化的数据访问接口。 
    * 数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。 
    * 资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。 
    * 数据抽象，提供更面向对象的数据操作。

持久层框架有：

    * Hibernate 
    * MyBatis 
    * TopLink 
    * Guzz 
    * jOOQ 
    * Spring Data 
    * ActiveJDBC

## 3、MyBatis中使用 `#` 和 `$` 书写占位符有什么区别？ 
`#` 将传入的数据都当成一个字符串，会对传入的数据自动加上引号；`$` 将传入的数据直接显示生成在 SQL 中。注意：使用 `$` 占位符可能会导致 SQL 注入攻击，能用 `#` 的地方就不要使用 `$`，写order by子句的时候应该用 `$` 而不是 `#`。

## 4、解释一下 MyBatis 中命名空间（namespace）的作用。 
* 在大型项目中，可能存在大量的 SQL 语句，这时候为每个 SQL 语句起一个唯一的标识（ID）就变得并不容易了。为了解决这个问题，在 MyBatis 中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中的每个 SQL 语句就成了定义在这个命名空间中的一个 ID。只要我们能够保证每个命名空间中这个 ID 是唯一的，即使在不同映射文件中的语句 ID 相同，也不会再产生冲突了。

* 绑定 Dao 接口，面向接口编程。

## 5、MyBatis 动态 SQL。
[学习网址](http://www.jb51.net/article/71528.htm)

MyBatis中用于实现动态SQL的元素主要有： 

    - if 
    - choose / when / otherwise 
    - trim 
    - where 
    - set 
    - foreach

**代码示例**

```xml?linenums
<select id="selectStudentsByCondition" parameterType="Student" resultType="Student">
		select * from student 
	<where>
		<if test="stuId != null and stuId != '' ">
			 AND stuId = #{stuId}
		</if>
		<if test="stuName != null and stuName != '' ">
			AND stuName like  CONCAT(CONCAT('%',#{stuName}),'%') 
		</if>
		<if test="stuAge != null and stuAge != '' ">
			 AND stuAge = #{stuAge}
		</if>
	</where>
</select>
```

```xml?linenums
<select id="selectStudentByIds" resultType="Student">
  	SELECT *  FROM student  WHERE stuId in
 	<foreach item="stuIds" index="index" collection="list" open="(" separator="," close=")">
       	#{stuId}
 	</foreach>
</select>
```

```xml?linenums
<update id="updateStudent" parameterType="Student" >
	update student
    <set>
     	<if test="stuName != null and stuName != ''">stuName=#{stuName},</if>
      	<if test="stuAge != null">stuAge=#{stuAge},</if>
   	</set>
    where stuId=#{stuId}
</update>
```

```xml?linenums
<select id="dynamicChooseTest" parameterType="Blog" resultType="Blog"> 
   select * from t_blog where 11 = 1 
   <choose> 
        <when test="title != null"> 
            and title = #{title} 
        </when> 
        <when test="content != null"> 
            and content = #{content} 
        </when> 
        <otherwise> 
            and owner = "owner1"
        </otherwise> 
    </choose> 
</select>
```

```xml?linenums
<select id="dynamicTrimTest" parameterType="Blog" resultType="Blog"> 
    select * from t_blog 
    <trim prefix="where" prefixOverrides="and |or"> 
        <if test="title != null"> 
            title = #{title} 
        </if> 
        <if test="content != null"> 
            and content = #{content} 
        </if> 
        <if test="owner != null"> 
            or owner = #{owner} 
        </if> 
    </trim> 
</select>
```

## 6、什么是IoC和DI？DI是如何实现的？
IoC 叫控制反转，是 Inversion of Control 的缩写，DI（Dependency Injection）叫依赖注入，是对 IoC 更简单的诠释。

控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的"控制反转"就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。IoC 体现了好莱坞原则 - "Don’t call me, we will call you"。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI 是对 IoC 更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。

依赖注入可以通过 `setter方法注入`（设值注入）、`构造器注入` 和 `接口注入` 三种方式来实现，Spring 支持 `setter注入` 和 `构造器注入`，通常使用 `构造器注` 入来注入必须的依赖关系，对于可选的依赖关系，则 `setter注入` 是更好的选择，`setter注入` 需要类提供无参构造器或者无参的静态工厂方法来创建对象。

## 7、Spring 中的 Bean 的作用域有哪些？

* `singleton` : 表示 Bean 在一个 Spring IOC 容器中只会有一个实例。
* `prototype` : 表示每次从 Spring IOC 获取 Bean 时，都会产生一个新的实例，`prototype` 通常翻译为原型（原型模式）。

> Spring 不能对一个 prototype bean 的整个生命周期负责，容器在初始化、配置、装饰或者是装配完一个 prototype 实例后，将它交给客户端，随后就对该 prototype 实例不闻不问了。不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法，而对 prototype 而言，任何配置好的析构生命周期回调方法都将不会被调用。 清除 prototype 作用域的对象并释放任何 prototype bean 所持有的昂贵资源，都是客户端代码的职责。（让 Spring 容器释放被 singleton 作用域 bean 占用资源的一种可行方式是，通过使用 bean 的后置处理器，该处理器持有要被清除的 bean 的引用。）

* `request` : 表示该针对每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP request 内有效。
* `session` : session 作用域表示该针对每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。
* `global session` : global session 作用域类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。

> request、session、global session 使用的时候首先要在初始化 web 的 web.xml 中做如下配置。

```xml?linenums
//Servlet 2.4 之后配置
<web-app>
   ...
  <listener>
    <listener-class>org.springframework.web.context.request.RequestContextListener</listener-class>
  </listener>
   ...
</web-app>

//Servlet 2.4 以前配置
<web-app>
 ..
 <filter> 
    <filter-name>requestContextFilter</filter-name> 
    <filter-class>org.springframework.web.filter.RequestContextFilter</filter-class>
 </filter> 
 <filter-mapping> 
    <filter-name>requestContextFilter</filter-name> 
    <url-pattern>/*</url-pattern>
 </filter-mapping>
   ...
</web-app>
```

**Request 配置示例**
```xml?linenums
<bean id="role" class="spring.chapter2.maryGame.Role" scope="request"/>
```

**Session 配置示例**
```xml?linenums
<bean id="role" class="spring.chapter2.maryGame.Role" scope="session"/>
```

**Global Session 配置示例**
```xml?linenums
<bean id="role" class="spring.chapter2.maryGame.Role" scope="global session"/>
```
